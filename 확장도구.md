# list_code_usages_csharp VS Code 확장 도구 설계

## 목적

C# 프로젝트에서 `list_code_usages` 도구가 실패하는 근본 원인을 해결하고, `vscode.executeReferenceProvider` API를 올바르게 활용하여 Node.js/Python과 동일한 수준의 심볼 검색 기능을 제공합니다.

## 근본 원인 분석

### list_code_usages의 작동 방식
```typescript
// 현재 list_code_usages의 추정 흐름
1. symbolName을 받음 (예: "Add")
2. filePath에서 심볼 정의 위치를 찾음 ← 여기서 실패!
3. vscode.executeReferenceProvider(uri, position)를 호출
4. 참조 목록 반환
```

### 문제점
| 문제 | 현재 상태 | 근본 원인 |
|------|----------|----------|
| 메서드/프로퍼티 검색 | ❌ Symbol not found | 심볼 정의 위치 찾기 실패 |
| Cross-file 참조 | ❌ 단일 파일만 검색 | 검색 범위를 filePath로만 제한 |
| 외부 라이브러리 | ❌ NuGet 패키지 미지원 | 메타데이터에만 있는 정의 못 찾음 |
| 클래스 검색 | ⚠️ Definition만 검색 | 부분적으로만 위치 찾기 성공 |

### VS Code UI vs list_code_usages
```
VS Code UI "Find All References" (F12 → Shift+F12)
✅ 마우스 커서 위치의 심볼을 직접 executeReferenceProvider로 전달
✅ Language Server가 모든 작업 처리
✅ 메서드, 외부 라이브러리 모두 정상 동작

list_code_usages 도구
❌ symbolName(문자열)으로 위치를 역으로 찾아야 함
❌ 정의 위치 찾기 로직이 제한적
❌ 메서드, 외부 라이브러리 실패
```

## 해결 전략

### 핵심 아이디어
기존 C# Language Server(OmniSharp/C# Dev Kit)의 `vscode.executeReferenceProvider`를 활용하되, **심볼 정의 위치를 찾는 로직을 개선**하고, **MCP 서버로 등록하여 GitHub Copilot과 통합**합니다.

### 기술 스택
- **VS Code Extension API** - 확장 도구 개발 (TypeScript/JavaScript)
- **Model Context Protocol (MCP)** - GitHub Copilot과 통합
- **vscode.executeReferenceProvider** - 기존 Language Server 활용
- **vscode.executeDefinitionProvider** - 심볼 정의 위치 찾기
- **vscode.executeWorkspaceSymbolProvider** - 프로젝트 전체 심볼 검색

### 개발 환경
```json
{
  "language": "TypeScript",
  "runtime": "Node.js",
  "vscode-api": "^1.80.0",
  "dependencies": {
    "vscode": "^1.80.0",
    "@modelcontextprotocol/sdk": "latest"
  }
}
```

### 두 가지 접근 방식

#### 방식 1: VS Code 확장 (Extension)
- **장점**: VS Code와 깊은 통합, Marketplace 배포 가능
- **단점**: VS Code 전용

#### 방식 2: MCP 서버
- **장점**: 여러 도구에서 재사용 가능 (Claude Desktop, VS Code 등)
- **단점**: 배포 복잡도 증가

**권장**: 두 가지를 모두 구현
1. VS Code 확장으로 기본 기능 제공
2. 확장 내부에서 MCP 서버 등록하여 Copilot과 통합

**중요**: Roslyn을 직접 사용하지 않고, VS Code가 이미 제공하는 API만 사용합니다.

## 아키텍처 설계

### 구조
```
list_code_usages_csharp/
├── src/
│   ├── extension.ts              # VS Code 확장 진입점
│   ├── symbolFinder.ts           # 개선된 심볼 위치 찾기
│   ├── usageFinder.ts            # executeReferenceProvider 래퍼
│   ├── commands.ts               # 명령 등록
│   └── mcp/
│       ├── server.ts             # MCP 서버 구현
│       └── provider.ts           # MCP 서버 정의 프로바이더
├── package.json                  # 확장 매니페스트 (MCP 설정 포함)
├── tsconfig.json                 # TypeScript 설정
└── README.md
```

### 컴포넌트 다이어그램
```
┌─────────────────────────────────┐
│  GitHub Copilot (Agent Mode)    │
│  "Find usages of Add"           │
└────────┬────────────────────────┘
         │
         │ MCP Tool Call
         ▼
┌─────────────────────────────────┐
│  MCP Server (Extension 내부)    │
│  - list_code_usages tool        │
│  - C# 전용 최적화               │
└────────┬────────────────────────┘
         │
         │ symbolName + filePath
         ▼
┌─────────────────────────────────┐
│  Extension: SymbolFinder        │
│  1. Workspace Symbol 검색       │
│  2. Definition Provider 활용    │
│  3. 심볼 위치(Position) 확보    │
└────────┬────────────────────────┘
         │
         │ Uri + Position
         ▼
┌─────────────────────────────────┐
│  VS Code API                    │
│  executeReferenceProvider       │
│  (기존 C# Language Server 활용)  │
└────────┬────────────────────────┘
         │
         │ Location[]
         ▼
┌─────────────────────────────────┐
│  결과 반환                       │
│  → MCP Tool Response            │
│  → GitHub Copilot               │
│  - Definition                   │
│  - All References               │
│  - Cross-file 포함              │
└─────────────────────────────────┘
```

### 핵심 차이점
```
기존 list_code_usages (추정)
symbolName → 파일 파싱 → 위치 찾기 (실패) → ❌

개선된 확장 (VS Code 명령)
symbolName → WorkspaceSymbolProvider → 위치 확보 → executeReferenceProvider → ✅

개선된 확장 + MCP (GitHub Copilot)
Copilot → MCP Tool → SymbolFinder → executeReferenceProvider → ✅
```

## 핵심 기능 설계

### 1. 개선된 심볼 찾기 (symbolFinder.ts)

```typescript
import * as vscode from 'vscode';

export class SymbolFinder {
    /**
     * symbolName으로부터 실제 위치를 찾는 개선된 로직
     */
    async findSymbolPosition(
        symbolName: string, 
        filePath: string
    ): Promise<vscode.Position | null> {
        const uri = vscode.Uri.file(filePath);
        const document = await vscode.workspace.openTextDocument(uri);
        
        // 전략 1: 문서 내 텍스트 검색 (간단한 케이스)
        const textPosition = this.findInDocument(document, symbolName);
        if (textPosition) {
            return textPosition;
        }
        
        // 전략 2: Workspace Symbol Provider 사용 (프로젝트 전체)
        const workspaceSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
            'vscode.executeWorkspaceSymbolProvider',
            symbolName
        );
        
        if (workspaceSymbols && workspaceSymbols.length > 0) {
            // filePath와 일치하거나 가장 가까운 심볼 선택
            const matchingSymbol = this.findBestMatch(workspaceSymbols, uri, symbolName);
            if (matchingSymbol) {
                return matchingSymbol.location.range.start;
            }
        }
        
        // 전략 3: Document Symbol Provider 사용 (파일 내)
        const documentSymbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider',
            uri
        );
        
        if (documentSymbols) {
            const symbol = this.findSymbolRecursive(documentSymbols, symbolName);
            if (symbol) {
                return symbol.range.start;
            }
        }
        
        return null;
    }
    
    private findInDocument(document: vscode.TextDocument, symbolName: string): vscode.Position | null {
        const text = document.getText();
        
        // C# 메서드/프로퍼티 패턴
        const patterns = [
            new RegExp(`\\b(public|private|protected|internal)\\s+.*\\s+${symbolName}\\s*\\(`, 'g'), // 메서드
            new RegExp(`\\b(public|private|protected|internal)\\s+.*\\s+${symbolName}\\s*{`, 'g'),   // 프로퍼티
            new RegExp(`\\bclass\\s+${symbolName}\\b`, 'g'),  // 클래스
            new RegExp(`\\binterface\\s+${symbolName}\\b`, 'g'), // 인터페이스
        ];
        
        for (const pattern of patterns) {
            const match = pattern.exec(text);
            if (match) {
                return document.positionAt(match.index);
            }
        }
        
        return null;
    }
    
    private findBestMatch(
        symbols: vscode.SymbolInformation[], 
        uri: vscode.Uri, 
        symbolName: string
    ): vscode.SymbolInformation | null {
        // 1. 정확한 파일 매칭 우선
        const exactFileMatch = symbols.find(s => 
            s.location.uri.toString() === uri.toString() && 
            s.name === symbolName
        );
        if (exactFileMatch) return exactFileMatch;
        
        // 2. 같은 프로젝트 내 매칭
        const sameProjectMatch = symbols.find(s => 
            s.name === symbolName
        );
        return sameProjectMatch || symbols[0];
    }
    
    private findSymbolRecursive(
        symbols: vscode.DocumentSymbol[], 
        symbolName: string
    ): vscode.DocumentSymbol | null {
        for (const symbol of symbols) {
            if (symbol.name === symbolName) {
                return symbol;
            }
            
            if (symbol.children && symbol.children.length > 0) {
                const found = this.findSymbolRecursive(symbol.children, symbolName);
                if (found) return found;
            }
        }
        return null;
    }
}
```

### 2. 참조 찾기 (usageFinder.ts)

```typescript
import * as vscode from 'vscode';
import { SymbolFinder } from './symbolFinder';

export interface Usage {
    filePath: string;
    line: number;
    column: number;
    kind: 'definition' | 'reference';
    text: string;
}

export class UsageFinder {
    private symbolFinder: SymbolFinder;
    
    constructor() {
        this.symbolFinder = new SymbolFinder();
    }
    
    async findAllUsages(symbolName: string, filePath: string): Promise<Usage[]> {
        // 1. 심볼 위치 찾기
        const position = await this.symbolFinder.findSymbolPosition(symbolName, filePath);
        
        if (!position) {
            throw new Error(`Symbol '${symbolName}' not found`);
        }
        
        const uri = vscode.Uri.file(filePath);
        
        // 2. executeReferenceProvider 호출 (기존 Language Server 활용!)
        const locations = await vscode.commands.executeCommand<vscode.Location[]>(
            'vscode.executeReferenceProvider',
            uri,
            position
        );
        
        if (!locations || locations.length === 0) {
            return [];
        }
        
        // 3. 결과 변환
        const usages: Usage[] = [];
        for (const location of locations) {
            const document = await vscode.workspace.openTextDocument(location.uri);
            const line = location.range.start.line;
            const text = document.lineAt(line).text.trim();
            
            usages.push({
                filePath: location.uri.fsPath,
                line: line + 1, // 1-based
                column: location.range.start.character + 1,
                kind: 'reference', // TODO: definition 구분
                text: text
            });
        }
        
        return usages;
    }
}
```

### 3. VS Code 명령 등록 (extension.ts)

```typescript
import * as vscode from 'vscode';
import { UsageFinder } from './usageFinder';
import { registerMcpServer } from './mcp/provider';

export function activate(context: vscode.ExtensionContext) {
    const usageFinder = new UsageFinder();
    
    // 1. VS Code 명령 등록 (직접 사용)
    const disposable = vscode.commands.registerCommand(
        'list_code_usages_csharp.findUsages',
        async (symbolName: string, filePath?: string) => {
            try {
                const targetPath = filePath || 
                    vscode.window.activeTextEditor?.document.uri.fsPath;
                
                if (!targetPath) {
                    vscode.window.showErrorMessage('No file specified');
                    return [];
                }
                
                return await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: `Finding usages of '${symbolName}'...`,
                    cancellable: false
                }, async () => {
                    const usages = await usageFinder.findAllUsages(symbolName, targetPath);
                    
                    vscode.window.showInformationMessage(
                        `Found ${usages.length} usages of '${symbolName}'`
                    );
                    
                    return usages;
                });
            } catch (error) {
                vscode.window.showErrorMessage(`Error: ${error}`);
                return [];
            }
        }
    );
    
    context.subscriptions.push(disposable);
    
    // 2. MCP 서버 등록 (GitHub Copilot 통합)
    registerMcpServer(context, usageFinder);
}

export function deactivate() {}
```

### 4. MCP 서버 정의 프로바이더 (mcp/provider.ts)

```typescript
import * as vscode from 'vscode';
import { UsageFinder } from '../usageFinder';

export function registerMcpServer(
    context: vscode.ExtensionContext, 
    usageFinder: UsageFinder
) {
    // MCP 서버 정의 프로바이더 등록
    const provider: vscode.McpServerDefinitionProvider = {
        // MCP 서버 정의 제공
        provideMcpServerDefinitions: () => {
            const serverDef: vscode.McpStdioServerDefinition = {
                id: 'csharp-code-usages',
                name: 'C# Code Usages',
                description: 'Find all usages of C# symbols with improved symbol resolution',
                command: 'node',
                args: [context.asAbsolutePath('out/mcp/server.js')],
                env: {
                    // 환경 변수 전달
                    VSCODE_WORKSPACE: vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || ''
                }
            };
            
            return [serverDef];
        },
        
        // MCP 서버 해석 (추가 설정이나 인증 필요 시)
        resolveMcpServerDefinition: async (definition) => {
            // 필요한 경우 추가 설정
            return definition;
        },
        
        // 서버 정의 변경 이벤트
        onDidChangeMcpServerDefinitions: new vscode.EventEmitter<void>().event
    };
    
    // MCP 서버 정의 프로바이더 등록
    const registration = vscode.lm.registerMcpServerDefinitionProvider(
        'csharp-usages-provider', // package.json의 id와 일치
        provider
    );
    
    context.subscriptions.push(registration);
}
```

### 5. MCP 서버 구현 (mcp/server.ts)

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
    McpError,
    ErrorCode
} from '@modelcontextprotocol/sdk/types.js';
import * as vscode from 'vscode';

// MCP 서버 인스턴스 생성
const server = new Server(
    {
        name: 'csharp-code-usages-mcp',
        version: '0.1.0'
    },
    {
        capabilities: {
            tools: {}
        }
    }
);

// 도구 목록 제공
server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
        tools: [
            {
                name: 'find_csharp_usages',
                description: 'Find all usages of a C# symbol (method, class, property) across the project',
                inputSchema: {
                    type: 'object',
                    properties: {
                        symbolName: {
                            type: 'string',
                            description: 'Name of the C# symbol to find usages for (e.g., "Add", "Calculator", "JsonConvert")'
                        },
                        filePath: {
                            type: 'string',
                            description: 'Path to the file containing the symbol definition'
                        }
                    },
                    required: ['symbolName', 'filePath']
                }
            }
        ]
    };
});

// 도구 호출 처리
server.setRequestHandler(CallToolRequestSchema, async (request) => {
    if (request.params.name !== 'find_csharp_usages') {
        throw new McpError(
            ErrorCode.MethodNotFound,
            `Unknown tool: ${request.params.name}`
        );
    }
    
    const { symbolName, filePath } = request.params.arguments as {
        symbolName: string;
        filePath: string;
    };
    
    try {
        // VS Code 명령 호출 (확장의 UsageFinder 재사용)
        const usages = await vscode.commands.executeCommand(
            'list_code_usages_csharp.findUsages',
            symbolName,
            filePath
        );
        
        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify(usages, null, 2)
                }
            ]
        };
    } catch (error: any) {
        throw new McpError(
            ErrorCode.InternalError,
            `Failed to find usages: ${error.message}`
        );
    }
});

// MCP 서버 시작
async function main() {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error('C# Code Usages MCP server running on stdio');
}

main().catch((error) => {
    console.error('Fatal error in MCP server:', error);
    process.exit(1);
});
```

## 외부 라이브러리 지원

### NuGet 패키지 심볼 처리

외부 라이브러리의 경우, `vscode.executeWorkspaceSymbolProvider`가 메타데이터를 기반으로 심볼을 찾아줍니다.

```typescript
// JsonConvert 같은 외부 라이브러리 심볼 검색 예시
const symbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
    'vscode.executeWorkspaceSymbolProvider',
    'JsonConvert'
);

// C# Language Server가 자동으로 NuGet 패키지 메타데이터 검색
// OmniSharp/C# Dev Kit가 이미 제공하는 기능 활용!
```

**핵심**: Roslyn을 직접 다룰 필요 없이, C# Language Server가 이미 제공하는 기능을 활용합니다.

### 작동 원리

```
1. WorkspaceSymbolProvider 호출
   ↓
2. C# Language Server (OmniSharp/C# Dev Kit)
   - 프로젝트 파일(.csproj) 파싱
   - NuGet 패키지 참조 확인
   - 메타데이터(.dll) 로드
   - 심볼 정보 반환
   ↓
3. Position 확보
   ↓
4. executeReferenceProvider
   - 프로젝트 내 모든 사용처 검색
   - 메타데이터는 정의만, 소스는 참조만
```

## 성능 최적화

### 1. 캐싱 전략
```typescript
export class SymbolCache {
    private cache = new Map<string, Map<string, vscode.Position>>();
    
    getCachedPosition(filePath: string, symbolName: string): vscode.Position | null {
        return this.cache.get(filePath)?.get(symbolName) || null;
    }
    
    setCachedPosition(filePath: string, symbolName: string, position: vscode.Position) {
        if (!this.cache.has(filePath)) {
            this.cache.set(filePath, new Map());
        }
        this.cache.get(filePath)!.set(symbolName, position);
    }
    
    invalidate(filePath: string) {
        this.cache.delete(filePath);
    }
}
```

### 2. 문서 변경 감지
```typescript
// 파일이 수정되면 캐시 무효화
vscode.workspace.onDidChangeTextDocument((event) => {
    symbolCache.invalidate(event.document.uri.fsPath);
});
```

### 3. 전략 우선순위
```
1. 캐시 확인 (즉시 반환)
   ↓ miss
2. 문서 내 텍스트 검색 (빠름, ~10ms)
   ↓ 실패
3. DocumentSymbolProvider (중간, ~50ms)
   ↓ 실패
4. WorkspaceSymbolProvider (느림, ~200ms, 하지만 가장 정확)
```

## VS Code 확장 매니페스트

```json
{
  "name": "list-code-usages-csharp",
  "displayName": "C# Code Usages Finder (Fixed)",
  "description": "Fixes list_code_usages for C# by properly using VS Code's Reference Provider API. Includes MCP server for GitHub Copilot integration.",
  "version": "0.1.0",
  "publisher": "your-publisher-name",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": ["Programming Languages", "AI"],
  "keywords": ["csharp", "c#", "references", "usages", "find-all-references", "mcp", "copilot"],
  "activationEvents": [
    "onLanguage:csharp"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "list_code_usages_csharp.findUsages",
        "title": "Find All Usages (C# - Fixed)"
      }
    ],
    "configuration": {
      "title": "C# Code Usages Finder",
      "properties": {
        "csharpUsages.enableCache": {
          "type": "boolean",
          "default": true,
          "description": "Enable symbol position caching for better performance"
        },
        "csharpUsages.searchStrategies": {
          "type": "array",
          "default": ["text", "document", "workspace"],
          "description": "Symbol search strategies in priority order",
          "items": {
            "type": "string",
            "enum": ["text", "document", "workspace"]
          }
        },
        "csharpUsages.enableMcpServer": {
          "type": "boolean",
          "default": true,
          "description": "Enable MCP server for GitHub Copilot integration"
        }
      }
    },
    "mcpServerDefinitionProviders": [
      {
        "id": "csharp-usages-provider",
        "label": "C# Code Usages MCP Server"
      }
    ]
  },
  "dependencies": {
    "vscode": "^1.80.0",
    "@modelcontextprotocol/sdk": "^0.6.0"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "^18.0.0",
    "typescript": "^5.0.0",
    "@vscode/vsce": "^2.19.0"
  },
  "scripts": {
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "package": "vsce package"
  }
}
```

## MCP 도구 사용 예시

### GitHub Copilot Agent Mode에서 사용

```
사용자: Find all usages of the Add method in MathUtils.cs

Copilot: [MCP tool: find_csharp_usages 호출]
         symbolName: "Add"
         filePath: "sample/csharp/MathUtils.cs"

결과: ✅ 5 usages found:
      1. MathUtils.cs:5:23 - public static int Add(int a, int b)
      2. Calculator.cs:10:20 - return MathUtils.Add(a, b);
      3. Calculator.cs:15:20 - return MathUtils.Add(x, y) * z;
      4. Program.cs:8:24 - int sum = MathUtils.Add(5, 3);
      5. Program.cs:12:28 - result = MathUtils.Add(result, 10);

Copilot: I found 5 usages of the `Add` method:
         - Definition in MathUtils.cs at line 5
         - 4 references across Calculator.cs and Program.cs
         
         Would you like me to show you any specific usage or refactor this method?
```

### MCP 도구 정의

```typescript
// GitHub Copilot이 인식하는 도구 정의
{
  name: 'find_csharp_usages',
  description: 'Find all usages of a C# symbol (method, class, property) across the project',
  inputSchema: {
    symbolName: 'Name of the symbol',
    filePath: 'Path to the file containing the symbol'
  },
  annotations: {
    title: 'Find C# Usages',
    readOnlyHint: true  // 읽기 전용, 확인 대화상자 표시 안 함
  }
}
```

## 개발 로드맵

### Phase 1: 기본 수정 (v0.1) - 1-2일
- [x] symbolName → Position 변환 로직 구현
- [x] executeReferenceProvider 래핑
- [x] 텍스트 기반 검색 (간단한 패턴)
- [x] 메서드/클래스 지원

**목표**: `Add` 메서드 검색 성공 (VS Code 명령)

### Phase 2: MCP 통합 (v0.2) - 2-3일
- [ ] MCP 서버 정의 프로바이더 구현
- [ ] MCP 서버 (stdio) 구현
- [ ] GitHub Copilot과 통합 테스트
- [ ] MCP 도구 메타데이터 최적화

**목표**: GitHub Copilot에서 `find_csharp_usages` 도구 사용 가능

### Phase 3: 고급 검색 (v0.3) - 1주
- [ ] WorkspaceSymbolProvider 통합
- [ ] DocumentSymbolProvider 통합
- [ ] 다중 전략 + 우선순위
- [ ] 캐싱 시스템

**목표**: 외부 라이브러리 `JsonConvert` 검색 성공

### Phase 4: 성능 & UX (v0.4) - 1주
- [ ] 검색 결과 UI 개선
- [ ] 진행 상황 표시
- [ ] 에러 처리 강화
- [ ] MCP 도구 응답 포맷 최적화
- [ ] 설정 옵션

**목표**: Node.js/Python과 동등한 사용자 경험

### Phase 5: 배포 (v1.0) - 선택사항
- [ ] Marketplace 배포
- [ ] MCP 서버 독립 실행 지원
- [ ] 다른 언어 지원 검토
- [ ] 문서화 개선

**목표**: 프로덕션 준비 완료

## 테스트 전략

### 단위 테스트 (Jest/Mocha)
```typescript
import * as assert from 'assert';
import { SymbolFinder } from '../src/symbolFinder';

suite('SymbolFinder Tests', () => {
    test('Find method in same file', async () => {
        const finder = new SymbolFinder();
        const position = await finder.findSymbolPosition(
            'Add', 
            'sample/csharp/MathUtils.cs'
        );
        
        assert.notStrictEqual(position, null);
        assert.strictEqual(position!.line, 4); // Add 메서드가 5번째 줄
    });
    
    test('Find external library symbol', async () => {
        const finder = new SymbolFinder();
        const position = await finder.findSymbolPosition(
            'JsonConvert',
            'sample/csharp/JsonHelper.cs'
        );
        
        assert.notStrictEqual(position, null);
    });
});
```

### 통합 테스트
```typescript
suite('Integration Tests', () => {
    test('Find usages cross-file', async () => {
        const usageFinder = new UsageFinder();
        const usages = await usageFinder.findAllUsages(
            'Add',
            'sample/csharp/MathUtils.cs'
        );
        
        assert.strictEqual(usages.length, 5); // Definition + 4 usages
        
        // Calculator.cs에서 사용 확인
        const calculatorUsage = usages.find(u => 
            u.filePath.includes('Calculator.cs')
        );
        assert.ok(calculatorUsage);
    });
});
```

### 실제 프로젝트 테스트
```bash
# sample/csharp 프로젝트로 테스트
1. Add 메서드: 5 usages 기대
2. Calculator 클래스: 4 usages 기대
3. JsonConvert: 3 usages 기대 (외부 라이브러리)
```

## 배포 계획

### 1. 로컬 개발
```bash
# 프로젝트 초기화
npm init -y
npm install --save-dev @types/vscode @types/node typescript
npm install @modelcontextprotocol/sdk

# TypeScript 컴파일
npm run compile

# VS Code에서 F5로 디버깅
# .vscode/launch.json 자동 생성됨
```

### 2. 로컬 테스트

#### VS Code 명령 테스트
```bash
# 확장 빌드
npm run compile

# sample/csharp 프로젝트 열기
code sample/csharp

# F5로 Extension Development Host 실행
# 명령 팔레트: "Find All Usages (C# - Fixed)"
```

#### MCP 서버 테스트
```bash
# MCP 서버 디버깅 설정 (.vscode/launch.json)
{
  "type": "node",
  "request": "launch",
  "name": "Debug MCP Server",
  "program": "${workspaceFolder}/out/mcp/server.js",
  "console": "integratedTerminal"
}

# GitHub Copilot에서 테스트
# Agent Mode 활성화
# "Find usages of Add method" 입력
# MCP 도구 호출 확인
```

### 3. VSIX 패키징
```bash
# vsce 설치
npm install -g @vscode/vsce

# VSIX 생성
vsce package

# 생성된 파일: list-code-usages-csharp-0.1.0.vsix
```

### 4. 로컬 설치 테스트
```bash
# VSIX 설치
code --install-extension list-code-usages-csharp-0.1.0.vsix

# MCP 서버 등록 확인
# MCP: List Servers 명령 실행
# "C# Code Usages" 서버 확인

# 또는 VS Code UI에서:
# Extensions → ... → Install from VSIX
```

### 5. Marketplace 배포 (선택)
```bash
# Publisher 계정 필요
# https://marketplace.visualstudio.com/manage

vsce publish

# MCP 서버는 확장과 함께 자동 배포됨
# 사용자가 확장 설치 시 MCP 서버도 함께 등록됨
```

### 6. MCP 서버 독립 배포 (선택)
```bash
# 확장 없이 MCP 서버만 배포하려면
# package.json 별도 생성
{
  "name": "csharp-code-usages-mcp-server",
  "main": "out/mcp/server.js",
  "bin": {
    "csharp-usages-mcp": "out/mcp/server.js"
  }
}

# npm 패키지로 배포
npm publish

# 사용자는 다음과 같이 설치
npm install -g csharp-code-usages-mcp-server

# .vscode/mcp.json에 수동 등록
{
  "mcpServers": {
    "csharp-usages": {
      "command": "csharp-usages-mcp",
      "args": []
    }
  }
}
```

## 예상 결과

### Before (현재 list_code_usages)
```bash
> Find all usages of Add in sample/csharp/MathUtils.cs
❌ Symbol 'Add' not found

> Find all usages of JsonConvert in sample/csharp/JsonHelper.cs
❌ Symbol 'JsonConvert' not found

> Find all usages of MathUtils in sample/csharp/MathUtils.cs
⚠️ 1 usage found (definition만, Calculator.cs/Program.cs 사용은 못 찾음)
```

### After (확장 설치 후)
```bash
> Find all usages of Add in sample/csharp/MathUtils.cs
✅ 5 usages found:
   1. MathUtils.cs:5:23 (definition) - public static int Add(int a, int b)
   2. Calculator.cs:10:20 (reference) - return MathUtils.Add(a, b);
   3. Calculator.cs:15:20 (reference) - return MathUtils.Add(x, y) * z;
   4. Program.cs:8:24 (reference) - int sum = MathUtils.Add(5, 3);
   5. Program.cs:12:28 (reference) - result = MathUtils.Add(result, 10);

> Find all usages of JsonConvert in sample/csharp/JsonHelper.cs
✅ 3 usages found:
   1. JsonHelper.cs:8:16 (reference) - return JsonConvert.SerializeObject(obj);
   2. JsonHelper.cs:13:16 (reference) - return JsonConvert.DeserializeObject<T>(json);
   3. JsonHelper.cs:18:20 (reference) - var settings = JsonConvert.DefaultSettings;

> Find all usages of MathUtils in sample/csharp/MathUtils.cs
✅ 6 usages found:
   1. MathUtils.cs:3:18 (definition) - public static class MathUtils
   2. Calculator.cs:5:12 (reference) - using statement
   3. Calculator.cs:10:20 (reference) - MathUtils.Add
   4. Calculator.cs:15:20 (reference) - MathUtils.Add
   5. Program.cs:8:24 (reference) - MathUtils.Add
   6. Program.cs:12:28 (reference) - MathUtils.Add
```

## 참고 자료

### VS Code API
- [Reference Provider API](https://code.visualstudio.com/api/references/vscode-api#vscode.executeReferenceProvider)
- [Workspace Symbol Provider](https://code.visualstudio.com/api/references/vscode-api#vscode.executeWorkspaceSymbolProvider)
- [Document Symbol Provider](https://code.visualstudio.com/api/references/vscode-api#vscode.executeDocumentSymbolProvider)
- [Extension API Guide](https://code.visualstudio.com/api)

### MCP (Model Context Protocol)
- [MCP Developer Guide](https://code.visualstudio.com/api/extension-guides/ai/mcp)
- [Register MCP Server in Extension](https://code.visualstudio.com/api/extension-guides/ai/mcp#register-an-mcp-server-in-your-extension)
- [MCP Specification](https://modelcontextprotocol.io/)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [VS Code MCP Extension Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/mcp-extension-sample)

### C# Language Server
- [OmniSharp](https://github.com/OmniSharp/omnisharp-vscode) - 오픈소스 C# Language Server
- [C# Dev Kit](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit) - Microsoft 공식 확장

### 관련 이슈
- VS Code GitHub Issues에서 `list_code_usages` + `C#` 검색
- Language Server Protocol 스펙: [LSP Specification](https://microsoft.github.io/language-server-protocol/)

### 유사 문제/솔루션
- [Finding References in VS Code](https://code.visualstudio.com/docs/editor/editingevolved#_peek)
- TypeScript/JavaScript는 왜 잘 작동하는가? (동일한 API 사용, 하지만 심볼 찾기가 더 robust)
- [Use MCP servers in VS Code](https://code.visualstudio.com/docs/copilot/customization/mcp-servers)

## 기대 효과

| 항목 | 현재 | 개선 후 (Extension) | 개선 후 (+ MCP) |
|------|------|---------------------|-----------------|
| 메서드 검색 | ❌ Symbol not found | ✅ 완전 지원 (5 usages) | ✅ Copilot에서 자동 호출 |
| Cross-file 참조 | ❌ 단일 파일만 | ✅ 프로젝트 전체 | ✅ 프로젝트 전체 |
| NuGet 심볼 | ❌ 못 찾음 | ✅ JsonConvert 등 검색 가능 | ✅ JsonConvert 등 검색 가능 |
| 검색 속도 | N/A | < 500ms (캐싱 시 < 50ms) | < 500ms |
| GitHub Copilot 통합 | ❌ | ⚠️ 수동 명령 | ✅ Agent Mode 자동 |
| 재사용성 | N/A | VS Code 전용 | 다른 MCP 클라이언트 가능 |
| **구현 복잡도** | N/A | **낮음 (Roslyn 불필요)** | **중간 (MCP SDK 추가)** |
| **유지보수** | N/A | **쉬움 (VS Code API만)** | **쉬움 (MCP 표준)** |

## 핵심 장점

### 1. 간단한 구현
- ❌ Roslyn, Language Server 직접 구현 불필요
- ✅ VS Code API만 사용 (TypeScript로 100-200 라인)
- ✅ 기존 C# Language Server 활용
- ✅ MCP SDK로 Copilot 통합 (추가 50-100 라인)

### 2. 호환성
- OmniSharp 사용 환경: ✅ 작동
- C# Dev Kit 사용 환경: ✅ 작동
- Language Server 없음: ❌ 작동 안 함 (하지만 이미 C# 개발 불가능한 상태)
- GitHub Copilot: ✅ MCP 도구로 자동 통합

### 3. 확장성
- 다른 언어 지원 가능 (같은 패턴)
- 기존 list_code_usages의 버그픽스로 활용 가능
- MCP 표준으로 Claude Desktop 등 다른 도구에서도 사용 가능

### 4. 사용자 경험
```
기존 워크플로우:
1. Copilot: "Find usages of Add" 
2. Copilot: ❌ "Symbol 'Add' not found"
3. 사용자: 수동으로 Find All References (Shift+F12)

개선된 워크플로우 (Extension):
1. Copilot: "Find usages of Add"
2. 사용자: 명령 팔레트 → "Find All Usages (C# - Fixed)"
3. ✅ 결과 표시

개선된 워크플로우 (Extension + MCP):
1. Copilot: "Find usages of Add"
2. Copilot: [자동으로 find_csharp_usages 도구 호출]
3. ✅ 결과를 자연어로 설명
```

## 결론

### 문제의 본질
`list_code_usages` 도구는 **심볼 이름(문자열)을 Position으로 변환하는 과정에서 실패**합니다. 특히 C#의 경우 메서드나 외부 라이브러리 심볼의 위치를 찾지 못하는 것이 근본 원인입니다.

### 해결 방법
Roslyn 같은 무거운 도구 없이, VS Code가 이미 제공하는 API를 조합하여 해결:

1. **VS Code Extension 레벨**
   - `executeWorkspaceSymbolProvider` - 프로젝트 전체 심볼 검색
   - `executeDocumentSymbolProvider` - 파일 내 심볼 검색  
   - `executeReferenceProvider` - 참조 찾기 (이미 잘 작동함)

2. **MCP 통합 레벨**
   - `vscode.lm.registerMcpServerDefinitionProvider` - MCP 서버 등록
   - `@modelcontextprotocol/sdk` - MCP 프로토콜 구현
   - GitHub Copilot Agent Mode와 자동 통합

### 구현 범위
- ✅ **간단**: TypeScript로 150-300 라인 (Extension + MCP)
- ✅ **빠름**: 2-4일 내 MVP 구현 가능
- ✅ **안정적**: VS Code API + MCP 표준, 외부 의존성 최소
- ✅ **효과적**: Node.js/Python과 동등한 기능 + Copilot 자동화
- ✅ **재사용 가능**: MCP 표준으로 다른 도구에서도 사용

### 다음 단계
1. `npm init` 으로 프로젝트 초기화
2. `symbolFinder.ts`, `usageFinder.ts`, `extension.ts` 구현
3. `mcp/provider.ts`, `mcp/server.ts` 구현 (MCP 통합)
4. `package.json`에 `mcpServerDefinitionProviders` 추가
5. `sample/csharp` 프로젝트로 테스트
6. GitHub Copilot Agent Mode에서 테스트
7. VSIX 패키징 및 배포

### MCP 통합의 가치
- **수동 작업 제거**: 사용자가 명령을 직접 실행할 필요 없음
- **자연어 인터페이스**: "Find usages of Add" → 자동으로 도구 호출
- **컨텍스트 인식**: Copilot이 결과를 분석하고 추가 작업 제안
- **표준 준수**: MCP 표준으로 다른 AI 도구에서도 활용 가능

이 확장을 통해 C# 개발자는:
1. 더 이상 "Symbol not found" 에러 없이 코드 검색 가능
2. GitHub Copilot이 자동으로 심볼 검색 수행
3. 검색 결과를 자연어로 이해하고 후속 작업 수행

---

**작성일**: 2025년 10월 31일  
**버전**: v3.0 (MCP 통합 추가)  
**핵심 개선**: 
- Language Server 직접 구현 대신 기존 API 활용  
- MCP 서버 등록으로 GitHub Copilot과 자동 통합
**라이선스**: MIT

