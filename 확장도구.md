# list_code_usages_csharp VS Code 확장 도구 설계

## 목적

C# 프로젝트에서 `list_code_usages` 도구가 실패하는 근본 원인을 해결하고, `vscode.executeReferenceProvider` API를 올바르게 활용하여 Node.js/Python과 동일한 수준의 심볼 검색 기능을 제공합니다.

## 근본 원인 분석

### list_code_usages의 작동 방식
```typescript
// 현재 list_code_usages의 추정 흐름
1. symbolName을 받음 (예: "Add")
2. filePath에서 심볼 정의 위치를 찾음 ← 여기서 실패!
3. vscode.executeReferenceProvider(uri, position)를 호출
4. 참조 목록 반환
```

### 문제점
| 문제 | 현재 상태 | 근본 원인 |
|------|----------|----------|
| 메서드/프로퍼티 검색 | ❌ Symbol not found | 심볼 정의 위치 찾기 실패 |
| Cross-file 참조 | ❌ 단일 파일만 검색 | 검색 범위를 filePath로만 제한 |
| 외부 라이브러리 | ❌ NuGet 패키지 미지원 | 메타데이터에만 있는 정의 못 찾음 |
| 클래스 검색 | ⚠️ Definition만 검색 | 부분적으로만 위치 찾기 성공 |

### VS Code UI vs list_code_usages
```
VS Code UI "Find All References" (F12 → Shift+F12)
✅ 마우스 커서 위치의 심볼을 직접 executeReferenceProvider로 전달
✅ Language Server가 모든 작업 처리
✅ 메서드, 외부 라이브러리 모두 정상 동작

list_code_usages 도구
❌ symbolName(문자열)으로 위치를 역으로 찾아야 함
❌ 정의 위치 찾기 로직이 제한적
❌ 메서드, 외부 라이브러리 실패
```

## 해결 전략

### 핵심 아이디어
기존 C# Language Server(OmniSharp/C# Dev Kit)의 `vscode.executeReferenceProvider`를 활용하되, **심볼 정의 위치를 찾는 로직을 개선**하고, **MCP 서버로 등록하여 GitHub Copilot과 통합**합니다.

### 기술 스택
- **VS Code Extension API** - 확장 도구 개발 (TypeScript/JavaScript)
- **Model Context Protocol (MCP)** - GitHub Copilot과 통합
- **vscode.executeReferenceProvider** - 기존 Language Server 활용
- **vscode.executeDefinitionProvider** - 심볼 정의 위치 찾기
- **vscode.executeWorkspaceSymbolProvider** - 프로젝트 전체 심볼 검색

### 개발 환경
```json
{
  "language": "TypeScript",
  "runtime": "Node.js",
  "vscode-api": "^1.80.0",
  "dependencies": {
    "vscode": "^1.80.0",
    "@modelcontextprotocol/sdk": "latest"
  }
}
```

### 두 가지 접근 방식

#### 방식 1: VS Code 확장 (Extension)
- **장점**: VS Code와 깊은 통합, Marketplace 배포 가능
- **단점**: VS Code 전용

#### 방식 2: MCP 서버
- **장점**: 여러 도구에서 재사용 가능 (Claude Desktop, VS Code 등)
- **단점**: 배포 복잡도 증가

**권장**: 두 가지를 모두 구현
1. VS Code 확장으로 기본 기능 제공
2. 확장 내부에서 MCP 서버 등록하여 Copilot과 통합

**중요**: Roslyn을 직접 사용하지 않고, VS Code가 이미 제공하는 API만 사용합니다.

## 아키텍처 설계

### 구조
```
list_code_usages_csharp/
├── src/
│   ├── extension.ts              # VS Code 확장 진입점
│   ├── symbolFinder.ts           # 개선된 심볼 위치 찾기
│   ├── usageFinder.ts            # executeReferenceProvider 래퍼
│   └── commands.ts               # 명령 등록
├── package.json                  # 확장 매니페스트
├── tsconfig.json                 # TypeScript 설정
└── README.md
```

### 컴포넌트 다이어그램
```
┌─────────────────────────┐
│  GitHub Copilot/User    │
│  list_code_usages 호출  │
└────────┬────────────────┘
         │
         │ symbolName + filePath
         ▼
┌─────────────────────────────────┐
│  Extension: SymbolFinder        │
│  1. Workspace Symbol 검색       │
│  2. Definition Provider 활용    │
│  3. 심볼 위치(Position) 확보    │
└────────┬────────────────────────┘
         │
         │ Uri + Position
         ▼
┌─────────────────────────────────┐
│  VS Code API                    │
│  executeReferenceProvider       │
│  (기존 C# Language Server 활용)  │
└────────┬────────────────────────┘
         │
         │ Location[]
         ▼
┌─────────────────────────────────┐
│  결과 반환                       │
│  - Definition                   │
│  - All References               │
│  - Cross-file 포함              │
└─────────────────────────────────┘
```

### 핵심 차이점
```
기존 list_code_usages (추정)
symbolName → 파일 파싱 → 위치 찾기 (실패) → ❌

개선된 확장
symbolName → WorkspaceSymbolProvider → 위치 확보 → executeReferenceProvider → ✅
```

## 핵심 기능 설계

### 1. 개선된 심볼 찾기 (symbolFinder.ts)

```typescript
import * as vscode from 'vscode';

export class SymbolFinder {
    /**
     * symbolName으로부터 실제 위치를 찾는 개선된 로직
     */
    async findSymbolPosition(
        symbolName: string, 
        filePath: string
    ): Promise<vscode.Position | null> {
        const uri = vscode.Uri.file(filePath);
        const document = await vscode.workspace.openTextDocument(uri);
        
        // 전략 1: 문서 내 텍스트 검색 (간단한 케이스)
        const textPosition = this.findInDocument(document, symbolName);
        if (textPosition) {
            return textPosition;
        }
        
        // 전략 2: Workspace Symbol Provider 사용 (프로젝트 전체)
        const workspaceSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
            'vscode.executeWorkspaceSymbolProvider',
            symbolName
        );
        
        if (workspaceSymbols && workspaceSymbols.length > 0) {
            // filePath와 일치하거나 가장 가까운 심볼 선택
            const matchingSymbol = this.findBestMatch(workspaceSymbols, uri, symbolName);
            if (matchingSymbol) {
                return matchingSymbol.location.range.start;
            }
        }
        
        // 전략 3: Document Symbol Provider 사용 (파일 내)
        const documentSymbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider',
            uri
        );
        
        if (documentSymbols) {
            const symbol = this.findSymbolRecursive(documentSymbols, symbolName);
            if (symbol) {
                return symbol.range.start;
            }
        }
        
        return null;
    }
    
    private findInDocument(document: vscode.TextDocument, symbolName: string): vscode.Position | null {
        const text = document.getText();
        
        // C# 메서드/프로퍼티 패턴
        const patterns = [
            new RegExp(`\\b(public|private|protected|internal)\\s+.*\\s+${symbolName}\\s*\\(`, 'g'), // 메서드
            new RegExp(`\\b(public|private|protected|internal)\\s+.*\\s+${symbolName}\\s*{`, 'g'),   // 프로퍼티
            new RegExp(`\\bclass\\s+${symbolName}\\b`, 'g'),  // 클래스
            new RegExp(`\\binterface\\s+${symbolName}\\b`, 'g'), // 인터페이스
        ];
        
        for (const pattern of patterns) {
            const match = pattern.exec(text);
            if (match) {
                return document.positionAt(match.index);
            }
        }
        
        return null;
    }
    
    private findBestMatch(
        symbols: vscode.SymbolInformation[], 
        uri: vscode.Uri, 
        symbolName: string
    ): vscode.SymbolInformation | null {
        // 1. 정확한 파일 매칭 우선
        const exactFileMatch = symbols.find(s => 
            s.location.uri.toString() === uri.toString() && 
            s.name === symbolName
        );
        if (exactFileMatch) return exactFileMatch;
        
        // 2. 같은 프로젝트 내 매칭
        const sameProjectMatch = symbols.find(s => 
            s.name === symbolName
        );
        return sameProjectMatch || symbols[0];
    }
    
    private findSymbolRecursive(
        symbols: vscode.DocumentSymbol[], 
        symbolName: string
    ): vscode.DocumentSymbol | null {
        for (const symbol of symbols) {
            if (symbol.name === symbolName) {
                return symbol;
            }
            
            if (symbol.children && symbol.children.length > 0) {
                const found = this.findSymbolRecursive(symbol.children, symbolName);
                if (found) return found;
            }
        }
        return null;
    }
}
```

### 2. 참조 찾기 (usageFinder.ts)

```typescript
import * as vscode from 'vscode';
import { SymbolFinder } from './symbolFinder';

export interface Usage {
    filePath: string;
    line: number;
    column: number;
    kind: 'definition' | 'reference';
    text: string;
}

export class UsageFinder {
    private symbolFinder: SymbolFinder;
    
    constructor() {
        this.symbolFinder = new SymbolFinder();
    }
    
    async findAllUsages(symbolName: string, filePath: string): Promise<Usage[]> {
        // 1. 심볼 위치 찾기
        const position = await this.symbolFinder.findSymbolPosition(symbolName, filePath);
        
        if (!position) {
            throw new Error(`Symbol '${symbolName}' not found`);
        }
        
        const uri = vscode.Uri.file(filePath);
        
        // 2. executeReferenceProvider 호출 (기존 Language Server 활용!)
        const locations = await vscode.commands.executeCommand<vscode.Location[]>(
            'vscode.executeReferenceProvider',
            uri,
            position
        );
        
        if (!locations || locations.length === 0) {
            return [];
        }
        
        // 3. 결과 변환
        const usages: Usage[] = [];
        for (const location of locations) {
            const document = await vscode.workspace.openTextDocument(location.uri);
            const line = location.range.start.line;
            const text = document.lineAt(line).text.trim();
            
            usages.push({
                filePath: location.uri.fsPath,
                line: line + 1, // 1-based
                column: location.range.start.character + 1,
                kind: 'reference', // TODO: definition 구분
                text: text
            });
        }
        
        return usages;
    }
}
```

### 3. VS Code 명령 등록 (extension.ts)

```typescript
import * as vscode from 'vscode';
import { UsageFinder } from './usageFinder';

export function activate(context: vscode.ExtensionContext) {
    const usageFinder = new UsageFinder();
    
    // list_code_usages 명령 override 또는 새로운 명령 등록
    const disposable = vscode.commands.registerCommand(
        'list_code_usages_csharp.findUsages',
        async (symbolName: string, filePath?: string) => {
            try {
                // filePath가 없으면 현재 활성 문서 사용
                const targetPath = filePath || 
                    vscode.window.activeTextEditor?.document.uri.fsPath;
                
                if (!targetPath) {
                    vscode.window.showErrorMessage('No file specified');
                    return [];
                }
                
                // 진행 상황 표시
                return await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: `Finding usages of '${symbolName}'...`,
                    cancellable: false
                }, async () => {
                    const usages = await usageFinder.findAllUsages(symbolName, targetPath);
                    
                    vscode.window.showInformationMessage(
                        `Found ${usages.length} usages of '${symbolName}'`
                    );
                    
                    return usages;
                });
            } catch (error) {
                vscode.window.showErrorMessage(`Error: ${error}`);
                return [];
            }
        }
    );
    
    context.subscriptions.push(disposable);
}

export function deactivate() {}
```

## 외부 라이브러리 지원

### NuGet 패키지 심볼 처리

외부 라이브러리의 경우, `vscode.executeWorkspaceSymbolProvider`가 메타데이터를 기반으로 심볼을 찾아줍니다.

```typescript
// JsonConvert 같은 외부 라이브러리 심볼 검색 예시
const symbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
    'vscode.executeWorkspaceSymbolProvider',
    'JsonConvert'
);

// C# Language Server가 자동으로 NuGet 패키지 메타데이터 검색
// OmniSharp/C# Dev Kit가 이미 제공하는 기능 활용!
```

**핵심**: Roslyn을 직접 다룰 필요 없이, C# Language Server가 이미 제공하는 기능을 활용합니다.

### 작동 원리

```
1. WorkspaceSymbolProvider 호출
   ↓
2. C# Language Server (OmniSharp/C# Dev Kit)
   - 프로젝트 파일(.csproj) 파싱
   - NuGet 패키지 참조 확인
   - 메타데이터(.dll) 로드
   - 심볼 정보 반환
   ↓
3. Position 확보
   ↓
4. executeReferenceProvider
   - 프로젝트 내 모든 사용처 검색
   - 메타데이터는 정의만, 소스는 참조만
```

## 성능 최적화

### 1. 캐싱 전략
```typescript
export class SymbolCache {
    private cache = new Map<string, Map<string, vscode.Position>>();
    
    getCachedPosition(filePath: string, symbolName: string): vscode.Position | null {
        return this.cache.get(filePath)?.get(symbolName) || null;
    }
    
    setCachedPosition(filePath: string, symbolName: string, position: vscode.Position) {
        if (!this.cache.has(filePath)) {
            this.cache.set(filePath, new Map());
        }
        this.cache.get(filePath)!.set(symbolName, position);
    }
    
    invalidate(filePath: string) {
        this.cache.delete(filePath);
    }
}
```

### 2. 문서 변경 감지
```typescript
// 파일이 수정되면 캐시 무효화
vscode.workspace.onDidChangeTextDocument((event) => {
    symbolCache.invalidate(event.document.uri.fsPath);
});
```

### 3. 전략 우선순위
```
1. 캐시 확인 (즉시 반환)
   ↓ miss
2. 문서 내 텍스트 검색 (빠름, ~10ms)
   ↓ 실패
3. DocumentSymbolProvider (중간, ~50ms)
   ↓ 실패
4. WorkspaceSymbolProvider (느림, ~200ms, 하지만 가장 정확)
```

## VS Code 확장 매니페스트

```json
{
  "name": "list-code-usages-csharp",
  "displayName": "C# Code Usages Finder (Fixed)",
  "description": "Fixes list_code_usages for C# by properly using VS Code's Reference Provider API",
  "version": "0.1.0",
  "publisher": "your-publisher-name",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": ["Programming Languages"],
  "keywords": ["csharp", "c#", "references", "usages", "find-all-references"],
  "activationEvents": [
    "onLanguage:csharp"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "list_code_usages_csharp.findUsages",
        "title": "Find All Usages (C# - Fixed)"
      }
    ],
    "configuration": {
      "title": "C# Code Usages Finder",
      "properties": {
        "csharpUsages.enableCache": {
          "type": "boolean",
          "default": true,
          "description": "Enable symbol position caching for better performance"
        },
        "csharpUsages.searchStrategies": {
          "type": "array",
          "default": ["text", "document", "workspace"],
          "description": "Symbol search strategies in priority order",
          "items": {
            "type": "string",
            "enum": ["text", "document", "workspace"]
          }
        }
      }
    }
  },
  "dependencies": {
    "vscode": "^1.80.0"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "^18.0.0",
    "typescript": "^5.0.0"
  },
  "scripts": {
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "package": "vsce package"
  }
}
```

## 개발 로드맵

### Phase 1: 기본 수정 (v0.1) - 1-2일
- [x] symbolName → Position 변환 로직 구현
- [x] executeReferenceProvider 래핑
- [x] 텍스트 기반 검색 (간단한 패턴)
- [x] 메서드/클래스 지원

**목표**: `Add` 메서드 검색 성공

### Phase 2: 고급 검색 (v0.2) - 1주
- [ ] WorkspaceSymbolProvider 통합
- [ ] DocumentSymbolProvider 통합
- [ ] 다중 전략 + 우선순위
- [ ] 캐싱 시스템

**목표**: 외부 라이브러리 `JsonConvert` 검색 성공

### Phase 3: 성능 & UX (v0.3) - 1주
- [ ] 검색 결과 UI 개선
- [ ] 진행 상황 표시
- [ ] 에러 처리 강화
- [ ] 설정 옵션

**목표**: Node.js/Python과 동등한 사용자 경험

### Phase 4: 통합 (v0.4) - 선택사항
- [ ] GitHub Copilot과 통합 테스트
- [ ] list_code_usages 명령 오버라이드 시도
- [ ] 다른 언어 지원 검토

**목표**: 기본 `list_code_usages` 대체

## 테스트 전략

### 단위 테스트 (Jest/Mocha)
```typescript
import * as assert from 'assert';
import { SymbolFinder } from '../src/symbolFinder';

suite('SymbolFinder Tests', () => {
    test('Find method in same file', async () => {
        const finder = new SymbolFinder();
        const position = await finder.findSymbolPosition(
            'Add', 
            'sample/csharp/MathUtils.cs'
        );
        
        assert.notStrictEqual(position, null);
        assert.strictEqual(position!.line, 4); // Add 메서드가 5번째 줄
    });
    
    test('Find external library symbol', async () => {
        const finder = new SymbolFinder();
        const position = await finder.findSymbolPosition(
            'JsonConvert',
            'sample/csharp/JsonHelper.cs'
        );
        
        assert.notStrictEqual(position, null);
    });
});
```

### 통합 테스트
```typescript
suite('Integration Tests', () => {
    test('Find usages cross-file', async () => {
        const usageFinder = new UsageFinder();
        const usages = await usageFinder.findAllUsages(
            'Add',
            'sample/csharp/MathUtils.cs'
        );
        
        assert.strictEqual(usages.length, 5); // Definition + 4 usages
        
        // Calculator.cs에서 사용 확인
        const calculatorUsage = usages.find(u => 
            u.filePath.includes('Calculator.cs')
        );
        assert.ok(calculatorUsage);
    });
});
```

### 실제 프로젝트 테스트
```bash
# sample/csharp 프로젝트로 테스트
1. Add 메서드: 5 usages 기대
2. Calculator 클래스: 4 usages 기대
3. JsonConvert: 3 usages 기대 (외부 라이브러리)
```

## 배포 계획

### 1. 로컬 개발
```bash
# 프로젝트 초기화
npm init -y
npm install --save-dev @types/vscode @types/node typescript

# TypeScript 컴파일
npm run compile

# VS Code에서 F5로 디버깅
# .vscode/launch.json 자동 생성됨
```

### 2. 로컬 테스트
```bash
# 확장 빌드
npm run compile

# sample/csharp 프로젝트 열기
code sample/csharp

# F5로 Extension Development Host 실행
# 명령 팔레트: "Find All Usages (C# - Fixed)"
```

### 3. VSIX 패키징
```bash
# vsce 설치
npm install -g vsce

# VSIX 생성
vsce package

# 생성된 파일: list-code-usages-csharp-0.1.0.vsix
```

### 4. 로컬 설치 테스트
```bash
# VSIX 설치
code --install-extension list-code-usages-csharp-0.1.0.vsix

# 또는 VS Code UI에서:
# Extensions → ... → Install from VSIX
```

### 5. Marketplace 배포 (선택)
```bash
# Publisher 계정 필요
# https://marketplace.visualstudio.com/manage

vsce publish
```

## 예상 결과

### Before (현재 list_code_usages)
```bash
> Find all usages of Add in sample/csharp/MathUtils.cs
❌ Symbol 'Add' not found

> Find all usages of JsonConvert in sample/csharp/JsonHelper.cs
❌ Symbol 'JsonConvert' not found

> Find all usages of MathUtils in sample/csharp/MathUtils.cs
⚠️ 1 usage found (definition만, Calculator.cs/Program.cs 사용은 못 찾음)
```

### After (확장 설치 후)
```bash
> Find all usages of Add in sample/csharp/MathUtils.cs
✅ 5 usages found:
   1. MathUtils.cs:5:23 (definition) - public static int Add(int a, int b)
   2. Calculator.cs:10:20 (reference) - return MathUtils.Add(a, b);
   3. Calculator.cs:15:20 (reference) - return MathUtils.Add(x, y) * z;
   4. Program.cs:8:24 (reference) - int sum = MathUtils.Add(5, 3);
   5. Program.cs:12:28 (reference) - result = MathUtils.Add(result, 10);

> Find all usages of JsonConvert in sample/csharp/JsonHelper.cs
✅ 3 usages found:
   1. JsonHelper.cs:8:16 (reference) - return JsonConvert.SerializeObject(obj);
   2. JsonHelper.cs:13:16 (reference) - return JsonConvert.DeserializeObject<T>(json);
   3. JsonHelper.cs:18:20 (reference) - var settings = JsonConvert.DefaultSettings;

> Find all usages of MathUtils in sample/csharp/MathUtils.cs
✅ 6 usages found:
   1. MathUtils.cs:3:18 (definition) - public static class MathUtils
   2. Calculator.cs:5:12 (reference) - using statement
   3. Calculator.cs:10:20 (reference) - MathUtils.Add
   4. Calculator.cs:15:20 (reference) - MathUtils.Add
   5. Program.cs:8:24 (reference) - MathUtils.Add
   6. Program.cs:12:28 (reference) - MathUtils.Add
```

## 참고 자료

### VS Code API
- [Reference Provider API](https://code.visualstudio.com/api/references/vscode-api#vscode.executeReferenceProvider)
- [Workspace Symbol Provider](https://code.visualstudio.com/api/references/vscode-api#vscode.executeWorkspaceSymbolProvider)
- [Document Symbol Provider](https://code.visualstudio.com/api/references/vscode-api#vscode.executeDocumentSymbolProvider)
- [Extension API Guide](https://code.visualstudio.com/api)

### C# Language Server
- [OmniSharp](https://github.com/OmniSharp/omnisharp-vscode) - 오픈소스 C# Language Server
- [C# Dev Kit](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit) - Microsoft 공식 확장

### 관련 이슈
- VS Code GitHub Issues에서 `list_code_usages` + `C#` 검색
- Language Server Protocol 스펙: [LSP Specification](https://microsoft.github.io/language-server-protocol/)

### 유사 문제/솔루션
- [Finding References in VS Code](https://code.visualstudio.com/docs/editor/editingevolved#_peek)
- TypeScript/JavaScript는 왜 잘 작동하는가? (동일한 API 사용, 하지만 심볼 찾기가 더 robust)

## 기대 효과

| 항목 | 현재 | 개선 후 |
|------|------|---------|
| 메서드 검색 | ❌ Symbol not found | ✅ 완전 지원 (5 usages) |
| Cross-file 참조 | ❌ 단일 파일만 | ✅ 프로젝트 전체 |
| NuGet 심볼 | ❌ 못 찾음 | ✅ JsonConvert 등 검색 가능 |
| 검색 속도 | N/A | < 500ms (캐싱 시 < 50ms) |
| Node.js/Python 동등성 | ❌ | ✅ 동일 수준 |
| **구현 복잡도** | N/A | **낮음 (Roslyn 불필요)** |
| **유지보수** | N/A | **쉬움 (VS Code API만 사용)** |

## 핵심 장점

### 1. 간단한 구현
- ❌ Roslyn, Language Server 직접 구현 불필요
- ✅ VS Code API만 사용 (TypeScript로 100-200 라인)
- ✅ 기존 C# Language Server 활용

### 2. 호환성
- OmniSharp 사용 환경: ✅ 작동
- C# Dev Kit 사용 환경: ✅ 작동
- Language Server 없음: ❌ 작동 안 함 (하지만 이미 C# 개발 불가능한 상태)

### 3. 확장성
- 다른 언어 지원 가능 (같은 패턴)
- 기존 list_code_usages의 버그픽스로 활용 가능

## 결론

### 문제의 본질
`list_code_usages` 도구는 **심볼 이름(문자열)을 Position으로 변환하는 과정에서 실패**합니다. 특히 C#의 경우 메서드나 외부 라이브러리 심볼의 위치를 찾지 못하는 것이 근본 원인입니다.

### 해결 방법
Roslyn 같은 무거운 도구 없이, VS Code가 이미 제공하는 3가지 API를 조합하여 해결:
1. `executeWorkspaceSymbolProvider` - 프로젝트 전체 심볼 검색
2. `executeDocumentSymbolProvider` - 파일 내 심볼 검색  
3. `executeReferenceProvider` - 참조 찾기 (이미 잘 작동함)

### 구현 범위
- ✅ **간단**: TypeScript로 100-200 라인
- ✅ **빠름**: 1-2일 내 MVP 구현 가능
- ✅ **안정적**: VS Code API만 사용, 외부 의존성 최소
- ✅ **효과적**: Node.js/Python과 동등한 기능 제공

### 다음 단계
1. `npm init` 으로 프로젝트 초기화
2. `symbolFinder.ts`, `usageFinder.ts`, `extension.ts` 구현
3. `sample/csharp` 프로젝트로 테스트
4. VSIX 패키징 및 배포

이 확장을 통해 C# 개발자는 더 이상 "Symbol not found" 에러 없이, 코드 검색을 완벽하게 활용할 수 있습니다.

---

**작성일**: 2025년 10월 31일  
**버전**: v2.0 (Roslyn 제거, VS Code API 기반으로 재설계)  
**핵심 개선**: Language Server 직접 구현 대신 기존 API 활용  
**라이선스**: MIT
